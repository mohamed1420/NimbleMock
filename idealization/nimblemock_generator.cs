// NimbleMock.SourceGenerator/MockProxyGenerator.cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace NimbleMock.SourceGenerator;

[Generator]
public class MockProxyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mockCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: IsMockOfCall,
                transform: GetMockType)
            .Where(static m => m is not null);

        var compilation = context.CompilationProvider.Combine(mockCalls.Collect());

        context.RegisterSourceOutput(compilation, GenerateProxies!);
    }

    private static bool IsMockOfCall(SyntaxNode node, CancellationToken ct)
        => node is InvocationExpressionSyntax
        {
            Expression: MemberAccessExpressionSyntax
            {
                Name.Identifier.ValueText: "Of" or "Partial",
                Expression: IdentifierNameSyntax { Identifier.ValueText: "Mock" }
            }
        };

    private static INamedTypeSymbol? GetMockType(
        GeneratorSyntaxContext context,
        CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var memberAccess = (MemberAccessExpressionSyntax)invocation.Expression;
        
        if (memberAccess.Name is not GenericNameSyntax generic)
            return null;

        var typeArg = generic.TypeArgumentList.Arguments[0];
        var typeInfo = context.SemanticModel.GetTypeInfo(typeArg, ct);
        
        return typeInfo.Type as INamedTypeSymbol;
    }

    private static void GenerateProxies(
        SourceProductionContext context,
        (Compilation Left, ImmutableArray<INamedTypeSymbol> Right) source)
    {
        var (compilation, types) = source;
        var uniqueTypes = types.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var type in uniqueTypes)
        {
            if (type is null) continue;
            
            var proxySource = GenerateProxy(type);
            context.AddSource(
                $"Mock_{type.Name}.g.cs",
                SourceText.From(proxySource, Encoding.UTF8));
        }
    }

    private static string GenerateProxy(INamedTypeSymbol interfaceType)
    {
        var sb = new StringBuilder();
        var typeName = interfaceType.Name;
        var proxyName = $"MockProxy_{typeName}";
        var ns = interfaceType.ContainingNamespace.ToDisplayString();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using NimbleMock;");
        sb.AppendLine();
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();
        sb.AppendLine($"internal sealed class {proxyName} : {typeName}");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly MockInstance<{typeName}> _instance;");
        sb.AppendLine();
        sb.AppendLine($"    public {proxyName}(MockInstance<{typeName}> instance)");
        sb.AppendLine("        => _instance = instance;");
        sb.AppendLine();

        var methods = interfaceType.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary);

        foreach (var method in methods)
        {
            GenerateMethod(sb, method, typeName);
        }

        sb.AppendLine("}");
        sb.AppendLine();
        
        // Generate factory extension
        sb.AppendLine($"internal static partial class MockProxy<{typeName}>");
        sb.AppendLine("{");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    private static {typeName} CreateProxy(MockInstance<{typeName}> instance)");
        sb.AppendLine($"        => new {proxyName}(instance);");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateMethod(
        StringBuilder sb,
        IMethodSymbol method,
        string interfaceTypeName)
    {
        var returnType = method.ReturnType.ToDisplayString();
        var methodName = method.Name;
        var parameters = string.Join(", ", method.Parameters.Select(p =>
            $"{p.Type.ToDisplayString()} {p.Name}"));
        var paramNames = string.Join(", ", method.Parameters.Select(p => p.Name));
        var paramCount = method.Parameters.Length;

        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public {returnType} {methodName}({parameters})");
        sb.AppendLine("    {");

        // Create method ID
        sb.AppendLine($"        var methodId = MethodId.From<{interfaceTypeName}>(");
        sb.AppendLine($"            x => x.{methodName}({GetDefaultArgs(method)}));");
        sb.AppendLine();

        // Record call
        if (paramCount > 0)
        {
            sb.AppendLine($"        _instance.RecordCall(methodId, new object?[] {{ {paramNames} }});");
        }
        else
        {
            sb.AppendLine("        _instance.RecordCall(methodId, Array.Empty<object?>());");
        }
        sb.AppendLine();

        // Get setup
        sb.AppendLine("        if (!_instance.TryGetSetup(methodId, out var setup))");
        
        if (method.ReturnsVoid)
        {
            sb.AppendLine("            return;");
        }
        else
        {
            sb.AppendLine($"            return default({returnType})!;");
        }
        
        sb.AppendLine();

        // Handle exceptions
        sb.AppendLine("        if (setup.IsException)");
        sb.AppendLine("            throw (Exception)setup.ReturnValue!;");
        sb.AppendLine();

        // Return value
        if (!method.ReturnsVoid)
        {
            sb.AppendLine($"        return ({returnType})setup.ReturnValue!;");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GetDefaultArgs(IMethodSymbol method)
    {
        if (method.Parameters.Length == 0)
            return "";

        return string.Join(", ", method.Parameters.Select(p =>
        {
            if (p.Type.IsValueType)
                return "default";
            return "default!";
        }));
    }
}

// NimbleMock.SourceGenerator/NimbleMock.SourceGenerator.csproj
/*
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    <LangVersion>latest</LangVersion>
    <Nullable>enable</Nullable>
    <EnforceExtendedAnalyzerRules>true</EnforceExtendedAnalyzerRules>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.CodeAnalysis.CSharp" Version="4.8.0" PrivateAssets="all" />
    <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.4" PrivateAssets="all" />
  </ItemGroup>
</Project>
*/

// Generated output example for IUserRepository:
/*
// <auto-generated/>
#nullable enable
using System;
using System.Runtime.CompilerServices;
using NimbleMock;

namespace MyApp.Repositories;

internal sealed class MockProxy_IUserRepository : IUserRepository
{
    private readonly MockInstance<IUserRepository> _instance;

    public MockProxy_IUserRepository(MockInstance<IUserRepository> instance)
        => _instance = instance;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public User GetById(int id)
    {
        var methodId = MethodId.From<IUserRepository>(
            x => x.GetById(default));

        _instance.RecordCall(methodId, new object?[] { id });

        if (!_instance.TryGetSetup(methodId, out var setup))
            return default(User)!;

        if (setup.IsException)
            throw (Exception)setup.ReturnValue!;

        return (User)setup.ReturnValue!;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async Task<bool> SaveAsync(User user)
    {
        var methodId = MethodId.From<IUserRepository>(
            x => x.SaveAsync(default!));

        _instance.RecordCall(methodId, new object?[] { user });

        if (!_instance.TryGetSetup(methodId, out var setup))
            return default(bool)!;

        if (setup.IsException)
            throw (Exception)setup.ReturnValue!;

        return await (Task<bool>)setup.ReturnValue!;
    }
}

internal static partial class MockProxy<IUserRepository>
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static IUserRepository CreateProxy(MockInstance<IUserRepository> instance)
        => new MockProxy_IUserRepository(instance);
}
*/