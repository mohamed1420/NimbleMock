using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis.SymbolDisplay;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using NimbleMock.SourceGenerator.Internal;

[Generator]
public class MockProxyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var mockCalls = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: IsMockOfCall,
                transform: GetMockType)
            .Where(static m => m is not null);

        var compilation = context.CompilationProvider.Combine(mockCalls.Collect());

        context.RegisterSourceOutput(compilation, GenerateProxies!);
    }

    private static bool IsMockOfCall(SyntaxNode node, CancellationToken ct)
        => node is InvocationExpressionSyntax
        {
            Expression: MemberAccessExpressionSyntax
            {
                Name.Identifier.ValueText: "Of" or "Partial",
                Expression: IdentifierNameSyntax { Identifier.ValueText: "Mock" }
            }
        };

    private static INamedTypeSymbol? GetMockType(
        GeneratorSyntaxContext context,
        CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;
        var memberAccess = (MemberAccessExpressionSyntax)invocation.Expression;
        
        if (memberAccess.Name is not GenericNameSyntax generic)
            return null;

        var typeArg = generic.TypeArgumentList.Arguments[0];
        var typeInfo = context.SemanticModel.GetTypeInfo(typeArg, ct);
        
        return typeInfo.Type as INamedTypeSymbol;
    }

    private static void GenerateProxies(
        SourceProductionContext context,
        (Compilation Left, ImmutableArray<INamedTypeSymbol> Right) source)
    {
        var (compilation, types) = source;
        var uniqueTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
        
        foreach (var type in types)
        {
            if (type != null)
                uniqueTypes.Add(type);
        }

        foreach (var type in uniqueTypes)
        {
            var (proxySource, factorySource) = GenerateProxy(type);
            context.AddSource(
                $"Mock_{type.Name}.g.cs",
                SourceText.From(proxySource, Encoding.UTF8));
            context.AddSource(
                $"Mock_{type.Name}_Factory.g.cs",
                SourceText.From(factorySource, Encoding.UTF8));
        }
    }

    private static (string ProxySource, string FactorySource) GenerateProxy(INamedTypeSymbol interfaceType)
    {
        var typeName = interfaceType.Name;
        var proxyName = $"MockProxy_{typeName}";
        var interfaceNs = interfaceType.ContainingNamespace.ToDisplayString();
        var fullTypeName = interfaceNs == "" 
            ? typeName 
            : $"{interfaceNs}.{typeName}";

        var typeNameForGeneric = interfaceType.ToDisplayString(
            SymbolDisplayFormat.MinimallyQualifiedFormat
                .WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle.Omitted));
        var proxySb = new StringBuilder();
        proxySb.AppendLine("// <auto-generated/>");
        proxySb.AppendLine("#nullable enable");
        proxySb.AppendLine("using System;");
        proxySb.AppendLine("using System.Runtime.CompilerServices;");
        proxySb.AppendLine("using NimbleMock.Internal;");
        proxySb.AppendLine();
        proxySb.AppendLine($"namespace {interfaceNs};");
        proxySb.AppendLine();
        proxySb.AppendLine($"internal sealed class {proxyName} : {fullTypeName}");
        proxySb.AppendLine("{");
        proxySb.AppendLine($"    private readonly NimbleMock.Internal.MockInstance<{fullTypeName}> _instance;");
        proxySb.AppendLine();
        proxySb.AppendLine($"    public {proxyName}(NimbleMock.Internal.MockInstance<{fullTypeName}> instance)");
        proxySb.AppendLine("        => _instance = instance;");
        proxySb.AppendLine();

        var methods = interfaceType.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(m => m.MethodKind == MethodKind.Ordinary)
            .ToArray();

        foreach (var method in methods)
        {
            CodeGenerationHelpers.GenerateMethodBody(proxySb, method, fullTypeName);
        }

        proxySb.AppendLine("}");

        var factorySb = new StringBuilder();
        factorySb.AppendLine("// <auto-generated/>");
        factorySb.AppendLine("#nullable enable");
        factorySb.AppendLine("using System;");
        factorySb.AppendLine("using NimbleMock.Internal;");
        if (interfaceNs != "")
        {
            factorySb.AppendLine($"using {interfaceNs};");
        }
        factorySb.AppendLine();
        factorySb.AppendLine("namespace NimbleMock.Internal;");
        factorySb.AppendLine();
        var factoryTypeParam = interfaceNs != "" ? typeName : fullTypeName;
        factorySb.AppendLine($"internal static class MockProxy_{typeName}_Factory");
        factorySb.AppendLine("{");
        factorySb.AppendLine("    [System.Runtime.CompilerServices.ModuleInitializer]");
        factorySb.AppendLine("    internal static void Initialize()");
        factorySb.AppendLine("    {");
        var proxyTypeRef = interfaceNs == "" ? proxyName : $"{interfaceNs}.{proxyName}";
        factorySb.AppendLine($"        NimbleMock.Internal.MockProxy<{factoryTypeParam}>.RegisterFactory(instance => new {proxyTypeRef}(instance));");
        factorySb.AppendLine("    }");
        factorySb.AppendLine("}");

        return (proxySb.ToString(), factorySb.ToString());
    }

}

